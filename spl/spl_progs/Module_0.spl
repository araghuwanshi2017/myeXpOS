// Function Number	        Function Name  	   Arguments	                 Return Value
// ACQUIRE_BUFFER = 1	   Acquire Buffer	   Buffer Number, PID	         NIL
// RELEASE_BUFFER = 2  	   Release Buffer	   Buffer Number, PID	         0 or -1
// ACQUIRE_DISK = 3	   Acquire Disk		   PID	                         NIL
// ACQUIRE_INODE = 4	   Acquire Inode	   Inodeindex, PID	         0 or -1
// RELEASE_INODE = 5	   Release Inode	   Inodeindex, PID	         0 or -1
// ACQUIRE_SEMAPHORE = 6   Acquire Semaphore       PID	                         Semaphore Table Index or -1
// RELEASE_SEMAPHORE = 7   Release Semaphore       Semaphore Table Index, PID    0 or -1
// ACQUIRE_TERMINAL = 8	   Acquire Terminal        PID	                         NIL
// RELEASE_TERMINAL = 9	   Release Terminal        PID	                         0 or -1

//*********************************** MODULE 0 (RESOURCE MANAGER MODULE) ***********************************

alias functionNum R1;
alias currentPID R2;
alias ST_Index R3; 
alias inode_idx R4;

// *** ACQUIRE_TERMINAL ***

if(R1 == ACQUIRE_TERMINAL) then

	while([TERMINAL_STATUS_TABLE] == 1) do
	

		[PROCESS_TABLE + currentPID*16 + 4] = WAIT_TERMINAL;

		//multipush(R0 , R1 , R2 , R3);
		backup;
		call MOD_5;
		restore;
		//multipop(R0 , R1 , R2 , R3);

	endwhile;

	[TERMINAL_STATUS_TABLE] = 1;
	[TERMINAL_STATUS_TABLE + 1] = currentPID;

	breakpoint;

	return ;

endif;

// ****

// *** RELEASE_TERMINAL ***

if(R1 == RELEASE_TERMINAL) then

	if([TERMINAL_STATUS_TABLE + 1] != currentPID) then 
	
		R0 = -1;
		return;
	
	else

		[TERMINAL_STATUS_TABLE] = 0;
		alias cnt R4;
		cnt = 0;
		while(cnt < 16) do

			if([PROCESS_TABLE + cnt * 16 + 4] == WAIT_TERMINAL) then 

				[PROCESS_TABLE + cnt * 16 + 4] = READY;

			endif;

			cnt = cnt + 1;

		endwhile;

		R0 = 0;
		return;

	endif;

endif;

// ****

// *** ACQUIRE_DISK ***

if(R1 == ACQUIRE_DISK) then
	
	while([DISK_STATUS_TABLE] == 1) do
		[PROCESS_TABLE + (R2 * 16) + 4] = WAIT_DISK;
	
		backup;
		call MOD_5;
		restore;

	endwhile;

	[DISK_STATUS_TABLE] = 1; // Setting 1 as Disk is acquired
	[DISK_STATUS_TABLE + 4] = R2; //Setting up  Pid at 4 Location
	
	return ;

endif; 

// ****

// *** ACQUIRE_SEMAPHORE ***

if(R1 == ACQUIRE_SEMAPHORE) then

	alias i R0;
	i = 0;
	while(i < 32) do

		if([SEMAPHORE_TABLE + i + 1] == 0) then

			[SEMAPHORE_TABLE + i] = -1;	
			[SEMAPHORE_TABLE + i + 1] = 1;

			return;

		endif;

		i = i + 4;

	endwhile;

	R0 = -1;
	return ;
endif;
	
// ****


// *** RELEASE_SEMAPHORE ***

if(R1 == RELEASE_SEMAPHORE) then

	if([SEMAPHORE_TABLE + R3 * 4] == R2) then

		[SEMAPHORE_TABLE + R3 * 4] = -1; //Unlocking the semaphore 

		alias i R4;
		i = 1;	
		while(i < 16) do

			if(([PROCESS_TABLE + i * 16 + 4] == WAIT_SEMAPHORE) && ([PROCESS_TABLE + i * 16 + 5] == R3)) then

				[PROCESS_TABLE + i * 16 + 4] = READY;

			endif;
			i = i + 1;
		endwhile;

	endif;

	[SEMAPHORE_TABLE + R3 * 4 + 1] = [SEMAPHORE_TABLE + R3 * 4 + 1] - 1; // Decrementing Process_Count	
	return ;

endif;	
// ****
			
// *** ACQUIRE_INODE ***
if(R1 == ACQUIRE_INODE) then

	while([FILE_STATUS_TABLE + inode_idx * 4] != -1) do
		// Change State of Process to (WAIT_FILE , inode_index); 
		[PROCESS_TABLE + currentPID * 16 + 4] = WAIT_FILE;
		[PROCESS_TABLE + currentPID * 16 + 5] = inode_idx;
		
		backup;	
		call MOD_5; //Calling Scheduler
		restore;

	endwhile;

// *** Checking whether File was deleted by the time the inode was acquired ***
	if([INODE_TABLE + inode_idx * 4 + 1] == -1) then	
		R0 = -1;
		return;
	endif;

// ****

// *** If Inode_Entry is valid ***
	[INODE_TABLE + inode_idx * 16] = currentPID;
	R0 = 0;
	return ;

endif;

// *** RELEASE_INODE ***
if(R1 == RELEASE_INODE) then

// Locking Pid is not equal to given PID
	if([FILE_STATUS_TABLE + inode_idx * 4] != currentPID) then
		R0 = -1; // Inode_Still Not Free Acquired Some Other Process
		return ;
	endif;

	[FILE_STATUS_TABLE + inode_idx * 4] = -1; // Freed the lock

	alias i R0;
	i = 1;
	while(i < 16) do
		if(([PROCESS_TABLE + i * 16 + 4] == WAIT_FILE) && ([PROCESS_TABLE + i * 16 + 5] == inode_idx)) then
			[PROCESS_TABLE + i * 16 + 4] = READY ;
		endif;
		i = i + 1;
	endwhile;

	R0 = 0;// Inode_Released

endif;
// ****

// **********___________***********
