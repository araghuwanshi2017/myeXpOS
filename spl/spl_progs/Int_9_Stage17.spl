
// ***************************** INT 9 (EXEC SYSTEM CALL) ******************************

//print "Entered in INT 9";
alias UserSP R0;
UserSP = SP;

//Set Mode Flag
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 9;

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
//Kernel Stack 
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

breakpoint;
backup;

alias name R1;
name = [([PTBR + 2 * ((UserSP - 4)/512)] * 512 + ((UserSP - 4) % 512))];
alias counter R2;
counter = 1;
alias Inode_Index R3;
Inode_Index = -1;

//print name;

while(counter < 16) do
	print ([INODE_TABLE + (counter * 16) + 1]);
	if(([INODE_TABLE + (counter * 16) + 1]) == name) then
		Inode_Index = counter;
		break;	
	endif;
	counter = counter + 1;
endwhile;
print Inode_Index;

alias Return_Value R4;
Return_Value = ([PTBR + 2 * ((UserSP - 1)/512)] * 512) + (UserSP - 1)%512;

if(Inode_Index == -1) then
	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
	SP = UserSP;
	[Return_Value] = -1;
	ireturn;
else
	backup;
	//Storing the required Values
	R1 = 3; //Function Number For Exit Process
	R2 = [SYSTEM_STATUS_TABLE + 1]; //PID
	call MOD_1;
	restore;

	alias user_Area_Page_Num R5;
	user_Area_Page_Num = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11];

	[MEMORY_FREE_LIST + user_Area_Page_Num] = [MEMORY_FREE_LIST + user_Area_Page_Num] + 1;  //Memory_Free_List
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1; //MEM_FREE_COUNT

	SP = (user_Area_Page_Num)* 512 - 1;   //Kernel Stack

	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 4] = RUNNING;
	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 7] = Inode_Index;

	PTBR = PAGE_TABLE_BASE + ([SYSTEM_STATUS_TABLE + 1] * 20);

// ********** PAGE_TABLE ************

//*** Library ***
	[PTBR + 0] = 63;
	[PTBR + 1] = "0100";
	[PTBR + 2] = 64;
	[PTBR + 3] = "0100";
// ****

// *** Heap ***
	backup;
	
	//Storing the Required Values
	backup;
	R1 = 1; // Function Number For Get Free Page
	R2 = [SYSTEM_STATUS_TABLE + 1]; // CurrentPID
	call MOD_2;
	[PTBR + 4] = R0; // [PTBR + 4]
	[PTBR + 5] = "0110";// Auxillary Bits
	restore;
	
	backup;
	R1 = 1; // Function Number For Get Free Page
	R2 = [SYSTEM_STATUS_TABLE + 1];
	call MOD_2;
	[PTBR + 6] = R0; // [PTBR + 6]
	[PTBR + 7] = "0110";// [PTBR + 7]
	restore;	

// ****

// *** Stack ***
	backup;
	R1 = 1;
	R2 = [SYSTEM_STATUS_TABLE + 1];
	call MOD_2;
	[PTBR + 16] = R0;    //[PTBR + 16]
	[PTBR + 17] = "0110"; //Auxillary Bits	
	restore;	

	backup;
	R1 = 1;	
	R2 = [SYSTEM_STATUS_TABLE + 1];
	call MOD_2;
	[PTBR + 18] = R0;
	[PTBR + 19] = "0110";
	restore;
// ****	

//*** Code_Pages ***
	alias i R7;
	alias j R8;	
	i = 0;
	j = 0;
	while(j < 4) do
		if([INODE_TABLE + (Inode_Index * 16) + 8 + j] != -1) then
			backup;
			R1 = 1;
			R2 = [SYSTEM_STATUS_TABLE + 1];
			call MOD_2;
			loadi(R0 , [INODE_TABLE + (([PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 7]) * 16) + 8 + j]); // loading codepages in memory
			[PTBR + 8 + i] = R0; 
			[PTBR + 9 + i] = "0100";	
			restore;
		else
			[PTBR + 8 + i] = -1;
        	        [PTBR + 9 + i] = "0000";
		endif;
		i = i + 2;
		j = j + 1;
	endwhile;

// ****			
     restore;

breakpoint;
[[PTBR + 16] * 512] = [[PTBR + 8] * 512 + 1] ;// Entry_Point SP = IP 

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0; //Mode_Flag to 0 
SP = 8 * 512 ; //User_Stack

PTBR = PAGE_TABLE_BASE + ([SYSTEM_STATUS_TABLE + 1] * 20);
endif;

ireturn;
	
// *******_______*******

