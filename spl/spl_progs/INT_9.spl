
// ***************************** INT 9 (EXEC SYSTEM CALL) ******************************

// ***************************** (FINAL VERSION) ******************************

//print "Entered in INT 9";
alias UserSP R0;
UserSP = SP;

//Set Mode Flag
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 9;

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
//Kernel Stack 
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

breakpoint;
backup;

alias name R1;
name = [([PTBR + 2 * ((UserSP - 4)/512)] * 512 + ((UserSP - 4) % 512))];
alias counter R2;
counter = 1;
alias Inode_Index R3;
Inode_Index = -1;

//print name;

while(counter < 16) do
	// print ([INODE_TABLE + (counter * 16) + 1]);
	if(([INODE_TABLE + (counter * 16)] == EXEC) && ([INODE_TABLE + (counter * 16) + 1]) == name) then
		Inode_Index = counter;
		break;	
	endif;
	counter = counter + 1;
endwhile;
print Inode_Index;

alias Return_Value R4;
Return_Value = ([PTBR + 2 * ((UserSP - 1)/512)] * 512) + (UserSP - 1)%512;

if(Inode_Index == -1) then
	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
	SP = UserSP;
	[Return_Value] = -1; //Invalid or Failure
	ireturn;
else

// *** Exit Currently Running Process ***
	backup;
	//Storing the required Values
	R1 = 3; //Function Number For Exit Process
	R2 = [SYSTEM_STATUS_TABLE + 1]; //PID
	call MOD_1;
	restore;

// ****
	alias user_Area_Page_Num R5;
	user_Area_Page_Num = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11]; //Allocated Same User Area Page

	[MEMORY_FREE_LIST + user_Area_Page_Num] = [MEMORY_FREE_LIST + user_Area_Page_Num] + 1;  //Memory_Free_List
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1; //MEM_FREE_COUNT

	SP = (user_Area_Page_Num)* 512 - 1;   //Kernel Stack Allocated Same User Area Page


// *** Initialization Of PER_PROCESS RESOURCE TABLE ***

//	alias Inc R7;
//	Inc = 0;
//	while(Inc < 16) do	
//		[SP + 512  - Inc] = -1;
//		Inc = Inc + 1;
//	endwhile;
	
// ****

	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 4] = RUNNING;
	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 7] = Inode_Index;

	PTBR = PAGE_TABLE_BASE + ([SYSTEM_STATUS_TABLE + 1] * 20);

breakpoint;
// ********** PAGE_TABLE ************

//*** Library ***
	[PTBR + 0] = 63;
	[PTBR + 1] = "0100";
	[PTBR + 2] = 64;
	[PTBR + 3] = "0100";
// ****
breakpoint;
// *** Invalidating Heap Entries ***	

	[PTBR + 4] = -1;
	[PTBR + 5] = "0000";
	
	[PTBR + 6] = -1;
	[PTBR + 7] = -1;

// ****

// *** Stack ***
	backup;
	R1 = 1; // Func Num For GET_FREE_PAGE
	call MOD_2;
	[PTBR + 16] = R0;    //[PTBR + 16]
	[PTBR + 17] = "0110"; //Auxillary Bits	
	restore;	

	backup;
	R1 = 1;	 // Func Num For GET_FREE_PAGE
	call MOD_2;
	[PTBR + 18] = R0;
	[PTBR + 19] = "0110";
	restore;
// ****	
breakpoint;
//*** Code_Pages ***
 
// *** Validating only one page ***
	backup;

	R1 = 5; //Func Num For GET_CODE_PAGE
	R3 = [INODE_TABLE + ([PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 7] * 16) + 8];
	call MOD_2;
		
	[PTBR + 8] = R0; // Code_Page
	[PTBR + 9] = "0100";	
	
	restore;
// ****
breakpoint;
// *** Invalidating Rest Of The Code Pages ***

	[PTBR + 10] = -1;
	[PTBR + 11] = "0000";
	[PTBR + 12] = -1;
	[PTBR + 13] = "0000";
	[PTBR + 14] = -1;
	[PTBR + 15] = "0000";


// ****	

breakpoint;

// *** Initialization Of DISK_MAP_TABLE of the Process ***
	counter = 0;
	alias cnt R6;
	cnt = 4; 
	while(counter < 16) do
		if(((counter >= 8) && (counter < 12)) && ([INODE_TABLE + R3 * 16 + counter] != -1)) then
			[DISK_MAP_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 10) + cnt] = [INODE_TABLE + R3 * 16 + counter];
			cnt = cnt + 1;
		else
			[DISK_MAP_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + counter] = -1;
		endif;
		counter = counter + 1;
	endwhile;
	

breakpoint;

[Return_Value] = 0; // Return Success

[[PTBR + 16] * 512] = [[PTBR + 8] * 512 + 1] ;// Entry_Point SP = IP 

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0; //Mode_Flag to 0 
SP = 8 * 512 ; //User_Stack

PTBR = PAGE_TABLE_BASE + ([SYSTEM_STATUS_TABLE + 1] * 20);
endif;


ireturn;
	
// ********________********

