
// ***************************** INT 9 (EXEC SYSTEM CALL) ******************************

// ***************************** (FINAL VERSION) ******************************

alias UserSP R0;
alias name R1;
alias currentPID R2;
alias Inode_Index R3;
alias user_Area_Page_Num R5;
alias cnt R6;
alias counter R7;
alias process_Table_Entry R8;
alias Return_Value R9;
alias Base_RT R10;


UserSP = SP;
currentPID = [SYSTEM_STATUS_TABLE + 1];
name = [([PTBR + 2 * ((UserSP - 4)/512)] * 512 + ((UserSP - 4) % 512))];
Inode_Index = -1;
counter = 1;
process_Table_Entry = PROCESS_TABLE + currentPID * 16;
Return_Value = [PTBR + 2 * ((UserSP - 1)/512)] * 512 + (UserSP - 1)%512;

[process_Table_Entry + 9] = 9;               //Set Mode Flag
[process_Table_Entry + 13] = SP;            //Saving UPTR
SP = [process_Table_Entry + 11] * 512 - 1; //Kernel Stack 

backup;


while(counter < 16) do
	if(([INODE_TABLE + (counter * 16)] == EXEC) && ([INODE_TABLE + (counter * 16) + 1]) == name) then
		Inode_Index = counter;
		break;	
	endif;
	counter = counter + 1;
endwhile;

if(Inode_Index == -1) then
	restore;
	[process_Table_Entry + 9] = 0;
	SP = UserSP;
	[Return_Value] = -1; //Invalid or Failure
	ireturn;
else

// *** Exit Currently Running Process ***
	backup;
	R1 = 3;                          //Function Number For Exit Process
	R2 = [SYSTEM_STATUS_TABLE + 1]; //PID
	call MOD_1;
	restore;

// ****
	user_Area_Page_Num = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11]; //Allocated Same User Area Page

	[MEMORY_FREE_LIST + user_Area_Page_Num] = [MEMORY_FREE_LIST + user_Area_Page_Num] + 1;  //Memory_Free_List
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1; //MEM_FREE_COUNT

	SP = (user_Area_Page_Num)* 512 - 1;   //Kernel Stack Allocated Same User Area Page


// *** Initialization Of PER_PROCESS RESOURCE TABLE ***

	Base_RT = (user_Area_Page_Num + 1)* 512 - 16;
	counter = 0;
	while(counter  < 16) do	
		[Base_RT + counter] = -1;
		counter = counter + 1;
	endwhile;
	
// ****

	[process_Table_Entry + 4] = RUNNING;
	[process_Table_Entry + 7] = Inode_Index;

	PTBR = PAGE_TABLE_BASE + currentPID * 20;

// ********** PAGE_TABLE ************

//*** Library ***
	[PTBR + 0] = 63;
	[PTBR + 1] = "0100";
	[PTBR + 2] = 64;
	[PTBR + 3] = "0100";
// ****

// *** Invalidating Heap Entries ***	

	[PTBR + 4] = -1;
	[PTBR + 5] = "0000";
	
	[PTBR + 6] = -1;
	[PTBR + 7] = -1;

// ****

// *** Stack ***
	backup;
	R1 = 1;                  //Func Num For GET_FREE_PAGE
	call MOD_2;             //Calling MMM
	[PTBR + 16] = R0;      //[PTBR + 16]
	[PTBR + 17] = "0110"; //Auxillary Bits	
	restore;	

	backup;
	R1 = 1;	                //Func Num For GET_FREE_PAGE
	call MOD_2;            //Calling MMM
	[PTBR + 18] = R0;     //Memory_Free_page
	[PTBR + 19] = "0110";//Auxillary_Bits
	restore;
// ****	

//*** Code_Pages ***
 
// *** Validating only one page ***
	backup;

	R1 = 5; //Func Num For GET_CODE_PAGE
	R3 = [INODE_TABLE + ([process_Table_Entry + 7] * 16) + 8];
	call MOD_2;
		
	[PTBR + 8] = R0; // Code_Page
	[PTBR + 9] = "0100";	
	
	restore;
// ****

// *** Invalidating Rest Of The Code Pages ***

	[PTBR + 10] = -1;
	[PTBR + 11] = "0000";
	[PTBR + 12] = -1;
	[PTBR + 13] = "0000";
	[PTBR + 14] = -1;
	[PTBR + 15] = "0000";


// ****	

// *** Initialization Of DISK_MAP_TABLE of the Process ***
	counter = 0;
	cnt = 4; 
	while(counter < 16) do
		if(((counter >= 8) && (counter < 12)) && ([INODE_TABLE + R3 * 16 + counter] != -1)) then
			[DISK_MAP_TABLE + (currentPID * 10) + cnt] = [INODE_TABLE + R3 * 16 + counter];
			cnt = cnt + 1;
		else
			[DISK_MAP_TABLE + (currentPID * 10) + counter] = -1;
		endif;
		counter = counter + 1;
	endwhile;
	

breakpoint;

[[PTBR + 2 * ((UserSP - 1)/512)] * 512 + (UserSP - 1)%512] = 0; // Return Success

[[PTBR + 16] * 512] = [[PTBR + 8] * 512 + 1] ;// Entry_Point SP = IP 

restore;


SP = 8 * 512 ;                                //User_Stack
[process_Table_Entry + 9] = 0;               //Mode_Flag to 0 
PTBR = PAGE_TABLE_BASE + (currentPID * 20); //PTBR
endif;

ireturn;
	
// ********________********

