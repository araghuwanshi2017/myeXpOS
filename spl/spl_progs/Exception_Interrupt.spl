
// ****************************** EXCEPTION INTERRUPT HANDLER ***************************

// ****************************** (FINAL VERSION) **************************
alias currentPID R2;
alias process_Table_Entry R3;

backup;
breakpoint;

currentPID = [SYSTEM_STATUS_TABLE + 1];
process_Table_Entry = PROCESS_TABLE + currentPID * 16;

[process_Table_Entry + 9] = -1;              //Set Mode Flag to -1 (Indicating In Exception Handler)
[process_Table_Entry + 13] = SP;            //Saving UPTR
SP = [process_Table_Entry + 11] * 512 - 1; //Switch to Kernel Stack;


multipush(EIP); //pushing the EIP value on the top of the kernel stack to resume execution if valid

if(EC != 0) then

// *** Illegal Instruction ***

	if(EC == 1) then
		print "!!Illegal!!";
	endif;

// ****
	
// *** Illegal Memory Access ***

	if(EC == 2) then
		print "!!Memory!!";
	endif;

// ****	

// *** Arithmetic Exception ***

	if(EC == 3) then
		print "!!Arith!!";
	endif;

// ****
	backup;
	R1 = EXIT_PROCESS; //Func_Num
	R2 = currentPID;   //PID
	call MOD_1;      //Calling PMM
	restore;
		
	backup;
	call MOD_5;
	restore;
endif;

// *** Page_fault ***


PTBR = PAGE_TABLE_BASE + (currentPID * 20);

breakpoint;	
if(EC == 0) then

// *** Page_Fault Due to Heap Page ***
	if((EPN >= 2) && (EPN <= 3)) then
		
		backup;	

		R1 = 1;
		call MOD_2;
		
		[PTBR + 4] = R0;
		[PTBR + 5] = "1110";
	
		restore;
		
		backup;

        R1 = 1;
        call MOD_2;

        [PTBR + 6] = R0;
        [PTBR + 7] = "1110";

        restore;
	else
		// *** Invoke Get_Code_Page ***
		backup;
	
		R1 = GET_CODE_PAGE;
		R3 = [DISK_MAP_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 10) + (EPN)];
		call MOD_2;
		breakpoint;
		[PTBR + (2 *EPN)] = R0;
		[PTBR + (2 *EPN) + 1] = "1100";

		restore;
	endif;

endif;

// ****


[process_Table_Entry + 9] = 0;
			
multipop(EIP); // Get the EIP value from the stack;
restore;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13];
SP = SP + 1;
[[PTBR + 2 *(SP/512)] * 512 + (SP)%512] = EIP;

ireturn;

// **********___________***********
