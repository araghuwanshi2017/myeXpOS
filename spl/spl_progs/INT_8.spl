 // ********************* INTERRUPT 8 (FORK SYSTEM CALL) **********************

breakpoint;

alias child_PID R0;
alias i R2;
alias  UserSP R3;
alias parent_Page_Table R4;
alias child_Page_Table R5;
alias child_Process_Table_Entry R6;
alias parent_Process_Table_Entry R7;
alias process_Table_Entry R10;
alias child_Base_RT R13;
alias parent_Base_RT R14;
alias Return_Value R15;

UserSP = SP;
process_Table_Entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16;
Return_Value = [PTBR + 2 * ((UserSP - 1)/512)] * 512 + (UserSP - 1) % 512;

[process_Table_Entry + 13] = SP;             // User_Stack UPTR
[process_Table_Entry + 9] = 8;              //Set Mode_Flag 
SP = [process_Table_Entry + 11] * 512 - 1; // Kernel_Stack (KPTR)


backup;

// *** Invoke Get_Pcb_Entry ***
	R1 = 1;
	call MOD_1;

	breakpoint;
// *** If No Free PCB_Enry Found ***
	if(R0 == -1) then
		[Return_Value] = -1;               // Return_Value as -1
		[process_Table_Entry + 9] = 0;    // Switching Back to User_Mode
		SP = [process_Table_Entry + 13]; // Setting User_Stack 
		ireturn;
	else
		[PROCESS_TABLE + R0 * 16 + 1] = R0;	// PID of child
	
parent_Page_Table = PAGE_TABLE_BASE + ([SYSTEM_STATUS_TABLE+ 1] * 20); // Process_PTBR
child_Page_Table = PAGE_TABLE_BASE + (R0 * 20);                        //Child_PTBR
	
// *** Allocating Heap Pages For Process ***
		if([parent_Page_Table + 4] == -1) then
			backup;
			R1 = GET_FREE_PAGE;
			call MOD_2;
			[PTBR + 4] = R0;
			[PTBR + 5] = "1110";	
			restore;

			backup;	
			R1 = GET_FREE_PAGE;
			call MOD_2;
			[PTBR + 6] = R0;
			[PTBR + 7] = "1110";
			restore;

		endif;
// ****

// *** Allocating Stack Pages and User_Area_Page For Child ***
		
child_Process_Table_Entry = PROCESS_TABLE + R0 * 16; //Child PROCESS_TABLE
parent_Process_Table_Entry = process_Table_Entry;   // Parent PROCESS_TABLE	


		backup;
		R1 = GET_FREE_PAGE;
		call MOD_2;
		[child_Page_Table + 16] = R0;
		[child_Page_Table + 17] = "0110"; 
		restore;
		
		backup;
		R1 = GET_FREE_PAGE;
		call MOD_2;
		[child_Page_Table + 18] = R0;
		[child_Page_Table + 19] = "0110";
		restore;
		
		backup;
		R1 = GET_FREE_PAGE;
		call MOD_2;
		[child_Process_Table_Entry + 11] = R0;
		restore;
// ****	


// *** Initialization of Process_Table For Child ***
	
 
	[child_Process_Table_Entry + 3] = [parent_Process_Table_Entry + 3];       // USERID
	[child_Process_Table_Entry + 6] = [parent_Process_Table_Entry + 6];      // SWAP_FLAG
	[child_Process_Table_Entry + 7] = [parent_Process_Table_Entry + 7];     // INODE_INDEX
	[child_Process_Table_Entry + 10] = [parent_Process_Table_Entry + 10];  // USER_AREA_SWAP_STATUS
	[child_Process_Table_Entry + 13] = [parent_Process_Table_Entry + 13]; // UPTR

	[child_Process_Table_Entry + 0] = 0;    //TICK
	[child_Process_Table_Entry + 9] = 0;   //MODE_FLAG
	[child_Process_Table_Entry + 12] = 0; //KPTR

	[child_Process_Table_Entry + 2] = [parent_Process_Table_Entry + 1];  // PPID = parentPID;
	[child_Process_Table_Entry + 4] = CREATED;                          // STATE
		
// ****

// *** Initialization Of Per_Process_Resource_Table ***

		child_Base_RT = ([PROCESS_TABLE + R0 * 16 + 11] + 1 )* 512 - 16;
		parent_Base_RT = ([process_Table_Entry + 11] + 1)* 512 - 16;

// *** Semaphore_Table *** 
	alias Sem_ID R8;
	i = 0;
	while(i < 16) do
		[child_Base_RT + i] = [parent_Base_RT + i];
		[child_Base_RT + i + 1] = [parent_Base_RT + i + 1];
		Sem_ID = [parent_Base_RT + i + 1];
		if([parent_Base_RT + i] != -1 && [parent_Base_RT + i] == SEMAPHORE) then
			[SEMAPHORE_TABLE + 4 * Sem_ID + 1] =  [SEMAPHORE_TABLE + 4 * Sem_ID + 1] + 1;// Incrementing Process count as Child is sharing the semaphore
		endif;
		i = i + 2;	
	endwhile;

// ****

// *** Open_File_Table *** 

	i = 0;
	alias Idx R8;
	while(i < 16) do
		[child_Base_RT + i] = [parent_Base_RT + i];
		[child_Base_RT + i + 1] = [parent_Base_RT + i + 1];
		Idx = [parent_Base_RT + i + 1];
		if([parent_Base_RT + i] != -1 && [parent_Base_RT + i] == FILE) then
			[OPEN_FILE_TABLE + 4 * Idx + 1] =  [OPEN_FILE_TABLE + 4 * Idx + 1] + 1;// Incrementing Process count as Child is sharing the semaphore
		endif;
		i = i + 2;	
	endwhile;
	
// ****
		
	
// *** Initialization Of Per_Prcess_Disk_Map_Table ***

	alias child_DMT R8;
	alias parent_DMT R9;
	child_DMT = DISK_MAP_TABLE + [R6 + 1]* 10;
	parent_DMT = DISK_MAP_TABLE + [R7 + 1] * 10;
	
	[child_DMT + 4] = [parent_DMT + 4];
	[child_DMT + 5] = [parent_DMT + 5];
	[child_DMT + 6] = [parent_DMT + 6];
	[child_DMT + 7] = [parent_DMT + 7];
	[child_DMT + 8] = -1;
	[child_DMT + 9] = -1;

// ****

// *** Initialization of Page_Table For Child ***

breakpoint;

	i = 0;
	while(i < 16) do
		[R5 + i] = [R4 + i];
		[R5 + i + 1] = [R4 + i + 1];
		if([R4 + i] != -1) then
			[MEMORY_FREE_LIST + [R4 + i]] = [MEMORY_FREE_LIST + [R4 + i]] + 1;
		endif;
		i = i + 2;
	endwhile;
	
alias child_Stack R11;
alias parent_Stack R12;

child_Stack = [R5 + 16] * 512;
parent_Stack = [R4 + 16] * 512;

// *** Copying Content of Stack From Parent to Child  ***

	if(parent_Stack != -1) then
		i = 0;
		while(i < 512) do
			[R11 + i] = [R12 + i];
			i = i + 1;
		endwhile;
	endif;

	child_Stack = [R5 + 18] * 512;
	parent_Stack = [R4 + 18] * 512;
	
	if(parent_Stack != -1) then
		i = 0;
		while(i < 512) do
			[R11 + i] = [R12 + i];
			i = i + 1;
		endwhile;
	endif;
	breakpoint;
// ***

// Storing BP on top of the Kernel Stack
	[[R6 + 11] * 512] = BP;

//child_Stack
	R12 = [R6 + 13]; // Child

//Parent_Stack
	R11 = [R7 + 13]; // Parent

// return Value For Child_Process as 0
	[[R5 + 2 * ((R12 - 1)/512)] * 512 + (R12 - 1) % 512] = 0;

// return Value For Parent_Process as child_PID
	[Return_Value] = [R6 + 1];

endif;

// ****

	restore;
	SP = R3;
	[process_Table_Entry + 9] = 0;//Setting Mode_Flag to 0
	
ireturn;
	
// ************____________*************

